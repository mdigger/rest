package rest

import (
	"bytes"
	"fmt"
	"io"
	"net"
	"os"
	"runtime"
	"time"
)

var (
	isTTY     bool      // флаг, что поддерживается вывод в цвете
	accessLog io.Writer // вывод в лог
)

func init() {
	// инициализируем вывод в лог
	SetLogger(os.Stderr)
}

// SetLogger позволяет определить вывод лога обработки запросов и ошибок.
// Если установлен флаг Debug, то в лог так же пишутся все запросы, которые
// вызвали ошибку и дамп вызовов функций, приведших к panic.
//
// Выглядит лог примерно так:
//
// 	2016/08/31 20:08:48 127.0.0.1          135.509µs     0.024Kb 200     GET /admin
// 	2016/08/31 20:08:48 127.0.0.1          432.314µs     0.000Kb 204  DELETE /admin
// 	2016/08/31 20:08:49 127.0.0.1           628.53µs     0.023Kb 200    POST /admin
// 	2016/08/31 20:08:50 127.0.0.1          546.106µs     0.000Kb 201    POST /users
// 	2016/08/31 20:08:50 127.0.0.1          571.342µs     0.000Kb 201    POST /users
// 	2016/08/31 20:08:51 127.0.0.1           156.24µs     0.058Kb 200     GET /users
// 	2016/08/31 20:08:52 127.0.0.1          891.372µs     0.000Kb 204     PUT /users/login
// 	2016/08/31 20:08:53 127.0.0.1          475.399µs     0.000Kb 204  DELETE /users/login
//
// Если вы хотите чтобы лог не выводился, установите его в nil.
func SetLogger(out io.Writer) {
	if out, ok := out.(*os.File); ok {
		fi, err := out.Stat()
		if err == nil {
			m := os.ModeDevice | os.ModeCharDevice
			isTTY = fi.Mode()&m == m
		}
	} else {
		isTTY = false
	}
	accessLog = out
}

// log выводит информацию в лог, если он определен.
func (c *Context) log() {
	if accessLog == nil {
		return // не выводим в лог, если он не определен
	}
	stop := time.Now()                   // время окончания обработки запроса
	buf := buffers.Get().(*bytes.Buffer) // формируем буфер для генерации лога
	buf.Reset()
	// время окончания обработки и вывода в лог
	buf.WriteString(stop.Format("2006/01/02 15:04:05"))
	// адрес пользователя
	remoteAddr := c.GetHeader("X-Real-IP")
	// Если IP-адрес путой, то смотрим на адрес proxy
	if remoteAddr == "" {
		remoteAddr = c.GetHeader("X-Forwarded-For")
	}
	// Если и этот адрес не указан, то читаем адрес socket
	if remoteAddr == "" {
		remoteAddr, _, _ = net.SplitHostPort(c.Request.RemoteAddr)
	}
	// адрес пользователя, продолжительность обработки и размер переданных данных
	fmt.Fprintf(buf, " %-15s %12v %9.3fKb ",
		remoteAddr, stop.Sub(c.started), float32(c.size)/1024)
	// Определяем цвет для вывода статуса, в зависимости от кода.
	if isTTY {
		buf.WriteString("\x1b[3")
		switch {
		case c.status < 200:
			buf.WriteRune('4') // blue
		case c.status < 300:
			buf.WriteRune('2') // green
		case c.status < 400:
			buf.WriteRune('3') // yellow
		case c.status < 500:
			buf.WriteRune('5') // magenta
		default:
			buf.WriteRune('1') // red
		}
		buf.WriteString(";2m")
	}
	fmt.Fprintf(buf, "%3d", c.status) // код ответа сервера
	if isTTY {
		buf.WriteString("\x1b[0m")
	}
	fmt.Fprintf(buf, " %7s ", c.Request.Method) // метод HTTP-запроса
	buf.WriteString(c.URL.RequestURI() + "\n")  // URL
	buf.WriteTo(accessLog)
	buffers.Put(buf)
}

// errorLog выводит в лог информацию об ошибке
func (c *Context) errorLog(err interface{}, callLevel int) {
	if accessLog == nil {
		return // не выводим в лог, если он не определен
	}
	buf := buffers.Get().(*bytes.Buffer) // формируем буфер для генерации лога
	buf.Reset()
	// время окончания обработки и вывода в лог
	buf.WriteString(time.Now().Format("2006/01/02 15:04:05"))
	// публикуем саму ошибку
	if isTTY {
		buf.WriteString(" \x1b[31mError:\x1b[0m ")
	} else {
		buf.WriteString(" Error: ")
	}
	fmt.Fprint(buf, err)
	// добавляем информацию о файле и строке, где произошла ошибка
	if Debug {
		_, file, line, ok := runtime.Caller(callLevel + 1)
		if ok && file != "<autogenerated>" {
			fmt.Fprintf(buf, " (%s:%d)", file, line)
		}
	}
	buf.WriteRune('\n')
	buf.WriteTo(accessLog)
	buffers.Put(buf)
}
